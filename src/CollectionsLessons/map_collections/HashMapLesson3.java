package CollectionsLessons.map_collections;

import java.util.HashMap;
import java.util.Map;

public final class HashMapLesson3 {
    // внутри класса Map есть класс Node который содержит key, value, hash, Node<K,V> next
    // В основе HashMap лежит массив. Элементами данного массива являются структуры LinkedList
    // Данные структуры LinkedList и заполняются элементами, которые мы добавляем в HasMap
    // При создании HashMap создается массив который называется table и содержит 16 ячеек
    // ячейки называются бакетами, внутри которых хранятся элементы, внутри одного бакета может находится несколько
    // элементов объединенных в LinkedList
    // При добавлении элемента в HashMap, берется хешкод ключа и определяется в какой бакет он положится
    // если у следующего элемента хешкод будет такой же он положится в ту же ячейку, но и если хеш код будет другим
    // элемент все равно может поместиться в тот же баскет
    // а если хешкоды одинаковые и equals вернет true то предыдущий элемент перезапишется
    // Но в ячейку помещается Node которая содержит хеш код, ключ, значение и ссылка на след элемент
    //
    //При методе get приосходит считывание хешкода ключа, и мы пониамем в какой бакет идти, дале элемент сравнивает
    // хешкод с хешкодами других элементов и когда находит такой же то проверяет на equals

    // При создании HasMap мы можем задать 2 параметра, которые очень влияют на производительность
    // Initial capacity - начальный размер массива
    // Load factor - коэффициент того, насколько массив должен быть заполне, после чего его размер будет увеличен вдвое
    // в Java 8 и далее сделали так что когда объектов в массиве очень много, Мар перестает хранить объекты в LinkedList
    // и начинает хранить их в сбалинсированных деревьях, в которых справа хранятся элемент больше, слева элемент меньше
    // и тут уже бинарнй поиск
    //В качестве ключа лучше назначть объекты immutable класс (неизменяемые)

    public static void main(String[] args) {
        Map<Integer, String> map1 = new HashMap<>(16, 0.75f);
        // Load factor 16 * 0.75 = 12 означает что после того как в Мар будет добавлено 12 элементов, Мар увеличиться вдвое
        // чем больше load factor тем меньше памяти мы будем использовать но скорость уменьшиться

    }
}
